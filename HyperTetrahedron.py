import pygame
from pygame.locals import *

from OpenGL.GL import *
from OpenGL.GLU import *
import math

import numpy as np
import scipy.linalg as slin


BLACK = (0,0,0)
WHITE = (1,1,1)
RED = (1,0,0)
GREEN = (0,1,0)
BLUE = (0,0,1)
YELLOW = (1,1,0)
MAGENTA = (1,0,1)
CYAN = (0,1,1)
ORANGE = (1,0.55, 0)
VIOLET = (0.5, 0, 1)
PINK = (1, 0.6, 1)

#returns true if 2 vectors are close enough to be equal, using math.islcose(a,b,abs_tol)
def closeEnough(a, b):
    if len(a) != len(b):
        return False
    ii = 0
    while ii < len(a):
        if not math.isclose(a[ii],b[ii],abs_tol=1e-6):
            return False
        ii+=1
    return True
    
class Object3d:
    vertices = []
    edges = []
    edgeColorList = []
    
    # 3 vectors to keep track of how the unit vectors have been oriented
    xTrans = [1,0,0]
    yTrans = [0,1,0]
    zTrans = [0,0,1]
    
    
    def rotateAroundY(self, angle):
        R = [[math.cos(angle),0,math.sin(angle)],[0,1,0],[-math.sin(angle),0,math.cos(angle)]]
        x = 0
        for v in self.vertices:
            arr = np.matmul(R, v)
            self.vertices[x] = arr.tolist()
            x+=1
        self.xTrans = np.matmul(R, self.xTrans)
        self.yTrans = np.matmul(R, self.yTrans)
        self.zTrans = np.matmul(R, self.zTrans)
    

            
    def rotateAroundX(self, angle):
        R = [[1,0,0],[0,math.cos(angle),-math.sin(angle)],[0,math.sin(angle),math.cos(angle)]]
        x = 0
        for v in self.vertices:
            arr = np.matmul(R, v)
            self.vertices[x] = arr.tolist()
            x+=1
        self.xTrans = np.matmul(R, self.xTrans)
        self.yTrans = np.matmul(R, self.yTrans)
        self.zTrans = np.matmul(R, self.zTrans)
    
    # sets orientation directly by left multiplication of a matrix with the inputs for columns
    def setOrientation(self, xTo, yTo, zTo):
        R = np.array([xTo, yTo, zTo]).transpose()
        self.xTrans = [1,0,0]
        self.yTrans = [0,1,0]
        self.zTrans = [0,0,1]
        x = 0
        for v in self.vertices:
            arr = np.matmul(R, v)
            self.vertices[x] = arr.tolist()
            x+=1
        self.xTrans = np.matmul(R, self.xTrans)
        self.yTrans = np.matmul(R, self.yTrans)
        self.zTrans = np.matmul(R, self.zTrans)
         
        
    def orderOfEdges(self):
        midpointZ = []
        for edge in self.edges:
            z1 = (self.vertices[edge[0]])[2]
            z2 = (self.vertices[edge[1]])[2]
            midpointZ.append(z1+z2)
        result = []
        while len(result) != len(self.edges):
            low = 0
            ii = 0
            for x in midpointZ:
                if x < midpointZ[low]:
                    low = ii
                ii+=1
            result.append(low)
            midpointZ[low] = 100
        return result
    
    def draw(self):
        order = self.orderOfEdges()
        glBegin(GL_LINES)
        for ii in order:
            glColor3fv(self.edgeColorList[ii])
            for vertex in self.edges[ii]:
                glVertex3fv(self.vertices[vertex])
        glEnd()

class Object4d:
    vertices = []
    edges = []
    edgeColorList = []
    
    # 3D object generated by projections of this object's vertices and edges
    projectionObject = Object3d()
    
    # angle for the projection
    pAngle = 0
    
    # returns a projection matrix that should be applied to vectors in 4D
    # left multiplication by the result yields the coordinates of a 3D projection of the vector
    def projectionMatrixFromAngle(self, angle):
        # The columns of A are a parameterized orthonormal basis for 4D euclidean space
        # The inverse of A is a basis-change from the standard euclidean basis to the columns of A
        A = [ [-math.sin(angle), 0, 0, math.cos(angle)],
            [math.cos(angle), 0, 0, math.sin(angle)], 
            [0, math.sin(angle/3), math.cos(angle/3), 0], 
            [0, math.cos(angle/3), -math.sin(angle/3), 0] ]
        # Left multiplication by D removes the last coordinate
        # D*inv(A) thus gives the coordinates a projection onto the subspace 
        # generated by the first 3 columns of A
        D = [ [1,0,0,0],[0,1,0,0],[0,0,0,1] ]
        return np.matmul(D, slin.inv(A))
        
        
    def projectionResult(self, v):
        P = self.projectionMatrixFromAngle(self.pAngle)
        return np.matmul(P, v).tolist()
    
    def initProjection(self):
        for v in self.vertices:
            self.projectionObject.vertices.append(self.projectionResult(v))
        self.projectionObject.edges = self.edges
        self.projectionObject.edgeColorList = self.edgeColorList
    
    # changes the 3 dimensional subspace which is being projected onto within 4 dimensional space
    # readjusts the orientation of the 3D projection to how it was oriented before the change of projection
    def updateProjection(self, angle):
        self.pAngle = angle
        xx = self.projectionObject.xTrans
        yy = self.projectionObject.yTrans
        zz = self.projectionObject.zTrans
        i=0
        for v in self.vertices:
            self.projectionObject.vertices[i] = self.projectionResult(v)
            i+=1
        self.projectionObject.setOrientation(xx, yy, zz)
        
        
     
    def rotateProjectionUp(self, angle):
        self.updateProjection(self.pAngle+angle)
    def rotateProjectionDown(self, angle):
        self.updateProjection(self.pAngle-angle)

class Pyramid(Object4d):
    # initializes vertices to the precalculated coordinates of a hypertetrahedron/hyperpyramid/4-simplex
    # initializes edges so 
    def __init__(self):
        self.vertices = [ [math.sqrt(360)/24,-math.sqrt(120)/24, -math.sqrt(15)/12, -1/4], 
                          [-math.sqrt(360)/24,-math.sqrt(120)/24, -math.sqrt(15)/12, -1/4],
                          [0,math.sqrt(120)/12, -math.sqrt(15)/12, -1/4], 
                          [0,0,-math.sqrt(15)/4,-1/4], 
                          [0,0,0,1] ]
        self.edges = ((0,1), (0,2), (0,3), (0,4), (1,2), (1,3), (1,4), (2,3), (2,4), (3,4) )
        self.edgeColorList = [RED, MAGENTA, ORANGE, CYAN, GREEN, WHITE, VIOLET, BLUE, PINK, YELLOW]
        self.initProjection()
        
class SymGraph(Object4d):
    outerPyramid = Pyramid()
    
    def __init__(self):
        self.firstpoint()
        self.addReflections()
        self.initProjection()
    
    
    def firstpoint(self):
        v1 = np.array(self.outerPyramid.vertices[0])
        v2 = np.array(self.outerPyramid.vertices[1])
        v3 = np.array(self.outerPyramid.vertices[2])
        v4 = np.array(self.outerPyramid.vertices[3])
        A = [[0.75,0,0,0],[0,0.75,0,0],[0,0,0.75,0],[0,0,0,0.75]]
        B = [[0.25,0,0,0],[0,0.25,0,0],[0,0,0.25,0],[0,0,0,0.25]]
        C = [[0.67,0,0,0],[0,0.67,0,0],[0,0,0.67,0],[0,0,0,0.67]]
        D = [[0.33,0,0,0],[0,0.33,0,0],[0,0,0.33,0],[0,0,0,0.33]]
        E = [[0.5,0,0,0],[0,0.5,0,0],[0,0,0.5,0],[0,0,0,0.5]]
        m = np.add(np.matmul(A,v1), np.matmul(B,v2))
        m = np.add(np.matmul(C, m), np.matmul(D, v3))
        result = np.add(np.matmul(E,m), np.matmul(E,v4))
        self.vertices.append(result.tolist())
    
    def addReflections(self):
        R1 = self.reflection1()
        R2 = self.reflection2()
        R3 = self.reflection3()
        R4 = self.reflection4()
        
        while len(self.vertices) < 120:
            for vertex in self.vertices:
                v1 = (np.matmul(R1, vertex)).tolist()
                alreadyIn = False
                for cmp in self.vertices:
                    if closeEnough(v1, cmp):
                        self.vertices[self.vertices.index(cmp)] = v1
                        alreadyIn = True
                        break
                if not alreadyIn:
                    self.vertices.append(v1)
                end1 = self.vertices.index(vertex)
                end2 = self.vertices.index(v1)
                if ((end1, end2) not in self.edges) and ((end2, end1) not in self.edges):
                    self.edges.append((end1,end2))
                    self.edgeColorList.append(RED)
                
                v2 = (np.matmul(R2, vertex)).tolist()
                alreadyIn = False
                for cmp in self.vertices:
                    if closeEnough(v2, cmp):
                        self.vertices[self.vertices.index(cmp)] = v2
                        alreadyIn = True
                        break
                if not alreadyIn:
                    self.vertices.append(v2)
                end1 = self.vertices.index(vertex)
                end2 = self.vertices.index(v2)
                if ((end1, end2) not in self.edges) and ((end2, end1) not in self.edges):
                    self.edges.append((end1, end2))
                    self.edgeColorList.append(GREEN)
                    
                v3 = (np.matmul(R3, vertex)).tolist()
                alreadyIn = False
                for cmp in self.vertices:
                    if closeEnough(v3, cmp):
                        self.vertices[self.vertices.index(cmp)] = v3
                        alreadyIn = True
                        break
                if not alreadyIn:
                    self.vertices.append(v3)
                end1 = self.vertices.index(vertex)
                end2 = self.vertices.index(v3)
                if ((end1, end2) not in self.edges) and ((end2, end1) not in self.edges):
                    self.edges.append((end1, end2))
                    self.edgeColorList.append(BLUE)
                
                v4 = (np.matmul(R4, vertex)).tolist()
                alreadyIn = False
                for cmp in self.vertices:
                    if closeEnough(v4, cmp):
                        self.vertices[self.vertices.index(cmp)] = v4
                        alreadyIn = True
                        break
                if not alreadyIn:
                    self.vertices.append(v4)
                end1 = self.vertices.index(vertex)
                end2 = self.vertices.index(v4)
                if ((end1, end2) not in self.edges) and ((end2, end1) not in self.edges):
                    self.edges.append((end1, end2))
                    self.edgeColorList.append(MAGENTA)
                
    
    
    #returns matrix for reflection which transposes 1st and 2nd vertices in outer hyperpyramid
    def reflection1(self):
        #3x4 matrix with 3 vertices of hyperpyramid as rows
        A = np.array([self.outerPyramid.vertices[2], self.outerPyramid.vertices[3], self.outerPyramid.vertices[4]])
        B = A.transpose()
        #4x4 matrix for projecting onto the subspace generated by rows of A
        P = np.matmul(B, np.matmul(slin.inv(np.matmul(A,B)),A))
        C = [[2,0,0,0],[0,2,0,0],[0,0,2,0],[0,0,0,2]]
        D = [[-1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,-1]]
        return np.add(np.matmul(C,P),D)
    
    #returns matrix for reflection which transposes 2nd and 3rd vertices in outer hyperpyramid
    def reflection2(self):
        #3x4 matrix with 3 vertices of hyperpyramid as rows
        A = np.array([self.outerPyramid.vertices[0], self.outerPyramid.vertices[3], self.outerPyramid.vertices[4]])
        B = A.transpose()
        #4x4 matrix for projecting onto the subspace generated by rows of A
        P = np.matmul(B, np.matmul(slin.inv(np.matmul(A,B)),A))
        C = [[2,0,0,0],[0,2,0,0],[0,0,2,0],[0,0,0,2]]
        D = [[-1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,-1]]
        return np.add(np.matmul(C,P),D)
    
    #returns matrix for reflection which transposes 3rd and 4th vertices in outer hyperpyramid
    def reflection3(self):
        #3x4 matrix with 3 vertices of hyperpyramid as rows
        A = np.array([self.outerPyramid.vertices[0], self.outerPyramid.vertices[1], self.outerPyramid.vertices[4]])
        B = A.transpose()
        #4x4 matrix for projecting onto the subspace generated by rows of A
        P = np.matmul(B, np.matmul(slin.inv(np.matmul(A,B)),A))
        C = [[2,0,0,0],[0,2,0,0],[0,0,2,0],[0,0,0,2]]
        D = [[-1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,-1]]
        return np.add(np.matmul(C,P),D)
    
    #returns matrix for reflection which transposes 4th and 5th vertices in outer hyperpyramid
    def reflection4(self):
        #3x4 matrix with 3 vertices of hyperpyramid as rows
        A = np.array([self.outerPyramid.vertices[0], self.outerPyramid.vertices[1], self.outerPyramid.vertices[2]])
        B = A.transpose()
        #4x4 matrix for projecting onto the subspace generated by rows of A
        P = np.matmul(B, np.matmul(slin.inv(np.matmul(A,B)),A))
        C = [[2,0,0,0],[0,2,0,0],[0,0,2,0],[0,0,0,2]]
        D = [[-1,0,0,0],[0,-1,0,0],[0,0,-1,0],[0,0,0,-1]]
        return np.add(np.matmul(C,P),D)
        
def main():
    pygame.init()
    display = (1000,750)
    pygame.display.set_mode(display, DOUBLEBUF|OPENGL)
    
    gluPerspective(45, (display[0]/display[1]), 0.1, 50.0)
    
    glTranslatef(0.0,0.0,-5.0)
    
    glRotate(0,0,0,0)
    
    SG = SymGraph()
    #pyr = Pyramid()
    
    dragging = False
    spinning = True
    prevPos = (-1,-1)
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                quit()
                '''
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    SG.rotateAroundY(-0.08)
                if event.key == pygame.K_RIGHT:
                    SG.rotateAroundY(0.08)
                if event.key == pygame.K_DOWN:
                    SG.rotateAroundX(0.08)
                if event.key == pygame.K_UP:
                    SG.rotateAroundX(-0.08)'''
                    
            elif event.type == pygame.KEYDOWN:
                '''if event.key == pygame.K_UP:
                    glTranslatef(0,0,0.5)
                if event.key == pygame.K_DOWN:
                    glTranslatef(0,0,-0.5)'''
                if event.key == pygame.K_SPACE:
                    spinning = not spinning
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 1:
                    dragging = True
                elif event.button == 4:
                    glTranslatef(0,0,0.5)
                elif event.button == 5:
                    glTranslatef(0,0,-0.5)
            elif event.type == pygame.MOUSEBUTTONUP:
                if event.button == 1:
                    dragging = False
                    prevPos = (-1,-1)
        
            
        
        if dragging:
            if prevPos == (-1,-1):
                prevPos = pygame.mouse.get_pos()
            else:
                difX = pygame.mouse.get_pos()[0] - prevPos[0]
                difY = pygame.mouse.get_pos()[1] - prevPos[1]
                SG.projectionObject.rotateAroundY(difX*0.01)
                #pyr.projectionObject.rotateAroundY(difX*0.01)
                SG.projectionObject.rotateAroundX(difY*0.01)
                #pyr.projectionObject.rotateAroundX(difX*0.01)
            prevPos = pygame.mouse.get_pos()
        if spinning:
            SG.rotateProjectionDown(0.02)
            #pyr.rotateProjectionDown(0.02)
        
        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
        
        
        
        SG.projectionObject.draw()
        #pyr.projectionObject.draw()
        
        
        pygame.display.flip()
        pygame.time.wait(10)
main()