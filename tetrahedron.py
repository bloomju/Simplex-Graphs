import pygame
from pygame.locals import *

from OpenGL.GL import *
from OpenGL.GLU import *
import math

import numpy as np
import scipy.linalg as slin


BLACK = (0,0,0)
WHITE = (1,1,1)
RED = (1,0,0)
GREEN = (0,1,0)
BLUE = (0,0,1)
YELLOW = (1,1,0)
MAGENTA = (1,0,1)
CYAN = (0,1,1)

#returns true if 2 vectors are close enough to be equal, using math.islcose(a,b,abs_tol)
def closeEnough(a, b):
	if len(a) != len(b):
		return False
	ii = 0
	while ii < len(a):
		if not math.isclose(a[ii],b[ii],abs_tol=1e-6):
			return False
		ii+=1
	return True


class Object3d:
	vertices = []
	edges = []
	sufaces = []
	
	def rotateAroundY(self, angle):
		R = [[math.cos(angle),0,math.sin(angle)],[0,1,0],[-math.sin(angle),0,math.cos(angle)]]
		x = 0
		for v in self.vertices:
			arr = np.matmul(R, v)
			self.vertices[x] = arr.tolist()
			x+=1
			
	def rotateAroundX(self, angle):
		R = [[1,0,0],[0,math.cos(angle),-math.sin(angle)],[0,math.sin(angle),math.cos(angle)]]
		x = 0
		for v in self.vertices:
			arr = np.matmul(R, v)
			self.vertices[x] = arr.tolist()
			x+=1
	def orderOfEdges(self):
		midpointZ = []
		for edge in self.edges:
			z1 = (self.vertices[edge[0]])[2]
			z2 = (self.vertices[edge[1]])[2]
			midpointZ.append(z1+z2)
		result = []
		while len(result) != len(self.edges):
			low = 0
			ii = 0
			for x in midpointZ:
				if x < midpointZ[low]:
					low = ii
				ii+=1
			result.append(low)
			midpointZ[low] = 100
		return result
			
	

class Tetrahedron(Object3d):
	def __init__(self):
		self.vertices = [
		[-math.sqrt(24)/6, -math.sqrt(8)/6, -1/3],
		[0, math.sqrt(8)/3, -1/3],
		[0,0,1],
		[math.sqrt(24)/6, -math.sqrt(8)/6, -1/3]
		]
		self.edges = (
		(0,1),
		(0,2),
		(0,3),
		(1,2),
		(1,3),
		(2,3)
		)
		self.edgeColorList = (RED,CYAN,MAGENTA,GREEN,YELLOW,BLUE)
	
	def draw(self):
		order = self.orderOfEdges()
		glBegin(GL_LINES)
		for ii in order:
			glColor3fv(self.edgeColorList[ii])
			for vertex in self.edges[ii]:
				glVertex3fv(self.vertices[vertex])
		glEnd()
		
		
class SymGraph(Object3d):
	outerTetra = Tetrahedron()
	#gives an initial point to build the rest
	edgeColorList = []
	def __init__(self):
		self.firstpoint()
		self.addReflections()
	
	
	def firstpoint(self):
		v1 = np.array(self.outerTetra.vertices[0])
		v2 = np.array(self.outerTetra.vertices[1])
		v3 = np.array(self.outerTetra.vertices[2])
		A = [[0.67,0,0],[0,0.67,0],[0,0,0.67]]
		B = [[0.33,0,0],[0,0.33,0],[0,0,0.33]]
		C = [[0.5,0,0], [0,0.5,0], [0,0,0.5]]
		m = np.add(np.matmul(A, v1),np.matmul(B, v2))
		result = np.add(np.matmul(C, m),np.matmul(C, v3))
		self.vertices.append(result.tolist())
	
	#appends reflections of v to the list if they haven't already been added
	#also adds a colored edge between points and their reflections, corresponding to which reflection
	def addReflections(self):
		R1 = self.reflection1()
		R2 = self.reflection2()
		R3 = self.reflection3()
		while len(self.vertices) < 24:
			for vertex in self.vertices:
				v1 = (np.matmul(R1, vertex)).tolist()
				alreadyIn = False
				for cmp in self.vertices:
					if closeEnough(v1, cmp):
						self.vertices[self.vertices.index(cmp)] = v1
						alreadyIn = True
						break
				if not alreadyIn:
					self.vertices.append(v1)
				end1 = self.vertices.index(vertex)
				end2 = self.vertices.index(v1)
				if ((end1, end2) not in self.edges) and ((end2, end1) not in self.edges):
					self.edges.append((end1, end2))
					self.edgeColorList.append(RED)	
				
				v2 = (np.matmul(R2, vertex)).tolist()
				alreadyIn = False
				for cmp in self.vertices:
					if closeEnough(v2, cmp):
						self.vertices[self.vertices.index(cmp)] = v2
						alreadyIn = True
						break
				if not alreadyIn:
					self.vertices.append(v2)
				end1 = self.vertices.index(vertex)
				end2 = self.vertices.index(v2)
				if ((end1, end2) not in self.edges) and ((end2, end1) not in self.edges):
					self.edges.append((end1, end2))
					self.edgeColorList.append(GREEN)
					
				v3 = (np.matmul(R3, vertex)).tolist()
				alreadyIn = False
				for cmp in self.vertices:
					if closeEnough(v3, cmp):
						self.vertices[self.vertices.index(cmp)] = v3
						alreadyIn = True
						break
				if not alreadyIn:
					self.vertices.append(v3)
				end1 = self.vertices.index(vertex)
				end2 = self.vertices.index(v3)
				if ((end1, end2) not in self.edges) and ((end2, end1) not in self.edges):
					self.edges.append((end1, end2))
					self.edgeColorList.append(BLUE)
					
					
	
	#returns matrix for reflection which transposes 1st and 2nd vertices in outer tetrahedron
	def reflection1(self):
		#2x3 matrix with 2 vertices of tetrahedron as rows
		A = np.array([self.outerTetra.vertices[2], self.outerTetra.vertices[3]])
		B = A.transpose()
		#3x3 matrix for projecting onto the subspace generated by rows of A
		P = np.matmul(B, np.matmul(slin.inv(np.matmul(A,B)), A))
		C = [[2,0,0],[0,2,0],[0,0,2]]
		D = [[-1,0,0],[0,-1,0],[0,0,-1]]
		return np.add(np.matmul(C,P),D)
	#returns matrix for reflection which transposes 2nd and 3rd vertices in outer tetrahedron
	def reflection2(self):
		#2x3 matrix with 2 vertices of tetrahedron as rows
		A = np.array([self.outerTetra.vertices[0], self.outerTetra.vertices[3]])
		B = A.transpose()
		#3x3 matrix for projecting onto the subspace generated by rows of A
		P = np.matmul(B, np.matmul(slin.inv(np.matmul(A,B)), A))
		C = [[2,0,0],[0,2,0],[0,0,2]]
		D = [[-1,0,0],[0,-1,0],[0,0,-1]] 
		return np.add(np.matmul(C,P),D)
	#returns matrix for reflection which transposes 3rd and 4th vertices in outer tetrahedron
	def reflection3(self):
		#2x3 matrix with 2 vertices of tetrahedron as rows
		A = np.array([self.outerTetra.vertices[0], self.outerTetra.vertices[1]])
		B = A.transpose()
		#3x3 matrix for projecting onto the subspace generated by rows of A
		P = np.matmul(B, np.matmul(slin.inv(np.matmul(A,B)), A))
		C = [[2,0,0],[0,2,0],[0,0,2]]
		D = [[-1,0,0],[0,-1,0],[0,0,-1]]
		return np.add(np.matmul(C,P),D)		
		
	def draw(self):
		order = self.orderOfEdges()
		glBegin(GL_LINES)
		for ii in order:
			glColor3fv(self.edgeColorList[ii])
			for vertex in self.edges[ii]:
				glVertex3fv(self.vertices[vertex])
		glEnd()
		
		
'''
def tetra():
	glBegin(GL_LINES)
	glColor3fv((0,0,0))
	
	
	for edge in edges:
		for vertex in edge:
			glVertex3fv(vertices[vertex])
	glEnd()
	
	glBegin(GL_TRIANGLES)
	glColor3fv((1,0,0))
	for vertex in (surfaces[0]):
		glVertex3fv(vertices[vertex])
	glColor3fv((0,1,0))
	for vertex in (surfaces[1]):
		glVertex3fv(vertices[vertex])
	glColor3fv((0,0,1))
	for vertex in (surfaces[2]):
		glVertex3fv(vertices[vertex])
	glColor3fv((1,1,0))
	for vertex in (surfaces[3]):
		glVertex3fv(vertices[vertex])
	glEnd()
	'''
	
	
def main():
	pygame.init()
	display = (1000,750)
	pygame.display.set_mode(display, DOUBLEBUF|OPENGL)
	
	gluPerspective(45, (display[0]/display[1]), 0.1, 50.0)
	
	glTranslatef(0.0,0.0,-5.0)
	
	glRotate(0,0,0,0)
	
	SG = SymGraph()
	print(SG.edges)
	
	T = Tetrahedron()
	dragging = False
	prevPos = (-1,-1)
	while True:
		for event in pygame.event.get():
			if event.type == pygame.QUIT:
				pygame.quit()
				quit()
				'''
			elif event.type == pygame.KEYDOWN:
				if event.key == pygame.K_LEFT:
					SG.rotateAroundY(-0.08)
				if event.key == pygame.K_RIGHT:
					SG.rotateAroundY(0.08)
				if event.key == pygame.K_DOWN:
					SG.rotateAroundX(0.08)
				if event.key == pygame.K_UP:
					SG.rotateAroundX(-0.08)'''
			elif event.type == pygame.MOUSEBUTTONDOWN:
				if event.button == 1:
					dragging = True
				elif event.button == 4:
					glTranslatef(0,0,1)
				elif event.button == 5:
					glTranslatef(0,0,-1)
			elif event.type == pygame.MOUSEBUTTONUP:
				if event.button == 1:
					dragging = False
					prevPos = (-1,-1)
			
		if dragging:
			if prevPos == (-1,-1):
				prevPos = pygame.mouse.get_pos()
			else:
				difX = pygame.mouse.get_pos()[0] - prevPos[0]
				difY = pygame.mouse.get_pos()[1] - prevPos[1]
				SG.rotateAroundY(difX*0.01)
				SG.rotateAroundX(difY*0.01)
				T.rotateAroundY(difX*0.01)
				T.rotateAroundX(difY*0.01)
			prevPos = pygame.mouse.get_pos()
		
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT)
		
		#SG.rotateAroundY(0.01)
		#T.rotateAroundY(0.01)
		
		T.draw()
		SG.draw()
		
		pygame.display.flip()
		pygame.time.wait(10)
main()